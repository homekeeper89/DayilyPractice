<script> const log = console.log</script>

<script>
const products = [
    {name:'반팔티', price:15000},
    {name:'긴팔티', price:20000},
    {name:'핸드폰케이스', price:15000},
    {name:'후드티', price:30000},
    {name:'바지', price:25000}
]
// 상품의 이름만 출력, 또는 가격만 따로 하는 등..
</script>
<script>
    // 함수형 프로그래밍은 인자와 리턴으로 소통하는 것을 권장
    // 그러므로 log(names)를 내부에서 뽑지않는다 -> 리턴 후 따로

    const map = (f, iter)=>{ // 어떤 값을 수집할지에 대해 추상화 한다(함수 f에게 위임한다), 직접 입력안함
        let res = [];
        for (const a of iter){
            res.push(f(a));
        }
        return res;
    }

    log(map(p => p.name, products)); // 전달한 함수는 p => p.name임

    let names = [];
    for(const p of products){
        names.push(p.name)
    }
    log(names)
</script>
<script>
    // map함수는 이터러블 프로토콜을 따라므로 다형성이 매우 높다
    //log(document.querySelectorAll('*').map(el => el.nodeName)); // 얘는 안됨, querySelectall은 어레이를 상속받았기 때문
    log(map(el => el.nodeName, document.querySelectorAll('*'))) // 얘가 되는 이유는 querySelectorAll이 이터러블 프로토콜을 따르기 때문, Symbol.iterator가 있다!
    
    function *gen(){
        yield 2;
        if (false) yield 3;
        yield 4;
    }

    log(map(a=> a*a, gen())) // 이터러블 프로토콜만 따르면 맵 함수는 사용 가능하다
    // 또한 문장(제너레이터) 역시도 사용 가능하다. => 사실상 대부분의 것들에 대해 사용가능
</script>
<script>
let m = new Map();
m.set('a', 10);
m.set('b', 20);
log(map(([k, a])=> [k, a*2], m));

</script>